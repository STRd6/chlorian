<!DOCTYPE html>

<html>
<head>
  <title>tech-talk</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="https://strd6.github.io/cdn/parallel/docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    <ul class="sections">
      <li id="section-1">
  <div class="annotation">
    <div class="pilwrap">
      <a class="pilcrow" href="#section-1">&#182;</a>
    </div>
    <h1 id="midi-chlorian">MIDI Chlorian</h1>

  </div>
  <div class="content"><pre><code>
</code></pre>
</div>
</li>
<li id="section-2">
  <div class="annotation">
    <div class="pilwrap">
      <a class="pilcrow" href="#section-2">&#182;</a>
    </div>
    <p>Deconstructing the world&#39;s best online MIDI player.</p>
<h2 id="wtf-is-midis-">WTF is MIDIs?</h2>

  </div>
  <div class="content"><pre><code>
</code></pre>
</div>
</li>
<li id="section-3">
  <div class="annotation">
    <div class="pilwrap">
      <a class="pilcrow" href="#section-3">&#182;</a>
    </div>
    <p>MIDI (/ˈmɪdi/; short for Musical Instrument Digital Interface) is a technical standard that 
describes a protocol, digital interface and connectors and allows a wide variety 
of electronic musical instruments, computers and other related devices to connect 
and communicate with one another. A single MIDI link can carry up to sixteen 
channels of information, each of which can be routed to a separate device.</p>
<ul>
<li><a href="http://oktopus.hu/uploaded/Tudastar/MIDI%201.0%20Detailed%20Specification.pdf">MIDI Specification</a></li>
<li><a href="https://www.midi.org/specifications/item/table-1-summary-of-midi-message">MIDI Message Summary</a></li>
</ul>
<h2 id="wtf-is-sound-fonts-">WTF is Sound Fonts?</h2>

  </div>
  <div class="content"><pre><code>
</code></pre>
</div>
</li>
<li id="section-4">
  <div class="annotation">
    <div class="pilwrap">
      <a class="pilcrow" href="#section-4">&#182;</a>
    </div>
    <p>MIDI files do not contain any sounds, only instructions to play them. Sound Fonts
contain information about how instruments sound and how those sounds evolve over time.</p>
<p>Sound Fonts encode all the data required to produce a sound including pitch, intonation,
expressiveness, timbre, and more.</p>
<p>You can imagine MIDI like being sheet music and a Sound Font like being an orchestra,
or storehouse of musical instruments.</p>
<p>If you put them both together in software you can play music!</p>
<ul>
<li><a href="http://freepats.zenvoid.org/sf2/sfspec24.pdf">Sound Font Technical Specification</a></li>
</ul>
<h2 id="web-audio-api">Web Audio API</h2>

  </div>
  <div class="content"><pre><code>
</code></pre>
</div>
</li>
<li id="section-5">
  <div class="annotation">
    <div class="pilwrap">
      <a class="pilcrow" href="#section-5">&#182;</a>
    </div>
    <p>In the browsers we have a few ways to play sounds. We can use the <code>&lt;audio&gt;</code> tag,
and programatically call things like <code>.play()</code> and <code>.pause()</code>. This is fine, but
it is very limited if we want to be able to play a wide range of sounds, we&#39;d
need a separate sample for every note. Effects like pitch bends, reverb, panning,
etc. would be impossible.</p>
<p>Enter the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API">Web Audio API</a>.
The Web Audio API provides ways to creat the digital audio workstation of your dreams.
You can use waveform generators to create sounds, read sound data from buffers,
schedule sounds to play with high precision and low latency, connect audio nodes
to a vast array of effect nodes including volume, reverb, panning, and more.</p>
<p>We finally can play MIDIs the way they were meant to be played.</p>
<h2 id="putting-it-all-together">Putting it all Together</h2>

  </div>
  <div class="content"><pre><code>
</code></pre>
</div>
</li>
<li id="section-6">
  <div class="annotation">
    <div class="pilwrap">
      <a class="pilcrow" href="#section-6">&#182;</a>
    </div>
    <p>Read binary SoundFont data</p>
<p>Read binary MIDI data</p>
<p>Load both into the player</p>
<p>The player is composed of a <code>track controller</code> and a <code>synthesizer</code>. </p>
<p>As the track controller reads the track events from the MIDI it updates its 
internal state and sends instructions to the synthesizer to control the sounds.</p>
<p>The synthesizer uses the loaded Sound Font data to control the browser&#39;s audio
context through the web audio api.</p>
<p>Because computers aren&#39;t magical and JS timing isn&#39;t 100% certain, we need to 
buffer the upcoming 0.25s - 2s of upcoming sounds so that we experience a smooth
playback experience.</p>
<p>We have an interval running as fast as the browser allows that checks to make sure
we&#39;re filling the upcoming buffer enough that we don&#39;t run out and stutter.</p>

  </div>
  <div class="content"><pre><code>
</code></pre>
</div>
</li>
    </ul>
  </div>
  <script src="https://code.jquery.com/jquery-1.10.1.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/coffee-script/1.6.3/coffee-script.min.js"></script><script>
  (function() {
  var ErrorReporter, bindUpdates, createEditor, exec, findInteractiveElements, readShebang, runners;

  createEditor = function(code, shebang, section) {
    var annotationElement, contentElement, editorElement, exampleSection, runtimeElement;
    exampleSection = $("<li>", {
      "class": "example"
    });
    annotationElement = $("<div>", {
      "class": "annotation"
    });
    editorElement = $("<textarea>", {
      "class": "annotation",
      text: code
    });
    contentElement = $("<div>", {
      "class": "content"
    });
    runtimeElement = $("<div>", {
      "class": "output"
    });
    contentElement.append(runtimeElement);
    annotationElement.append(editorElement);
    exampleSection.append(annotationElement);
    exampleSection.append(contentElement);
    section.after(exampleSection);
    return bindUpdates(shebang, editorElement, runtimeElement);
  };

  bindUpdates = function(shebang, editorElement, runtimeElement) {
    return editorElement.on("keyup", function() {
      var e, report, source;
      report = ErrorReporter(editorElement);
      source = editorElement.val();
      try {
        runners[shebang]({
          editorElement: editorElement,
          source: source,
          runtimeElement: runtimeElement
        });
        return report.clear();
      } catch (_error) {
        e = _error;
        return report(e);
      }
    });
  };

  readShebang = function(source) {
    var match;
    if (match = source.match(/^\#\! (.*)\n/)) {
      return match[1];
    }
  };

  ErrorReporter = function(editor) {
    var reporter;
    reporter = function(error) {
      var errorParagraph;
      if (editor.next().is("p.error")) {
        return editor.next().text(error);
      } else {
        errorParagraph = $("<p>", {
          "class": "error",
          text: error.toString()
        });
        return editor.after(errorParagraph);
      }
    };
    reporter.clear = function() {
      if (editor.next().is("p.error")) {
        return editor.next().remove();
      }
    };
    return reporter;
  };

  findInteractiveElements = function() {
    return $("blockquote > pre > code").each(function() {
      var blockQuoteElement, code, codeElement, sectionElement, shebang;
      codeElement = $(this);
      code = codeElement.text();
      if (shebang = readShebang(code)) {
        if (!runners[shebang]) {
          return;
        }
        code = code.split("\n").slice(1).join("\n");
        blockQuoteElement = codeElement.parent().parent();
        sectionElement = blockQuoteElement.parent().parent();
        blockQuoteElement.remove();
        return createEditor(code, shebang, sectionElement);
      }
    });
  };

  runners = {};

  (typeof window !== "undefined" && window !== null ? window : global).Interactive = {
    register: function(name, runner) {
      runners[name] = runner;
      findInteractiveElements();
      return $('#container').on('keyup', 'textarea', function() {
        $(this).height(0);
        return $(this).height(this.scrollHeight);
      }).find('textarea').keyup();
    }
  };

  exec = function(_arg) {
    var code, editorElement, runtimeElement, source;
    source = _arg.source, code = _arg.code, editorElement = _arg.editorElement, runtimeElement = _arg.runtimeElement;
    runtimeElement.remove();
    editorElement.replaceWith($("<pre>", {
      text: source
    }));
    return setTimeout(function() {
      return Function(code)();
    }, 0);
  };

  $(function() {
    Interactive.register("setup", function(params) {
      params.code = CoffeeScript.compile(params.source);
      return exec(params);
    });
    return Interactive.register("setup-js", function(params) {
      params.code = params.source;
      return exec(params);
    });
  });

}).call(this);

</script><script src="package.js"></script>
</body>
</html>